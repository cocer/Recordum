<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Recordum]]></title><description><![CDATA[All about Recordum]]></description><link>https://acyort.am0200.com</link><generator>RSS for Node</generator><lastBuildDate>Sun, 29 Jul 2018 05:22:19 GMT</lastBuildDate><atom:link href="https:/acyort.am0200.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 29 Jul 2018 05:22:19 GMT</pubDate><item><title><![CDATA[Pavane]]></title><description><![CDATA[<p>Pavane 是一个基于 Node.js 的 LiveReload Server 工具。</p>
<p>提供修改文件自动刷新浏览器页面的能力。Pavane 提供丰富的自定义选项，满足大部分的使用开发需求。</p>
<!-- more -->

<p>项目地址：<a href="https://github.com/fratercula/pavane">https://github.com/fratercula/pavane</a></p>
<h2>安装</h2><pre><code>$ npm i pavane -D # 作为模块使用
$ npm i pavane -g # 全局 CLI 使用</code></pre><h2>使用</h2><p>Pavane 既可以作为一个 Node 模块使用，也可以作为一个命令行工具全局使用，还可以在其他 web 服务上使用</p>
<h3>Node 模块</h3><pre><code>const { join, extname } &#x3D; require(&#39;path&#39;)
const Pavane &#x3D; require(&#39;pavane&#39;)

&#x2F;*
  监听目录
  文件, 目录, glob 匹配, 或者 数组
  默认: 当前运行目录
*&#x2F;
const watches &#x3D; join(process.cwd(), &#39;src&#39;)

&#x2F;*
  静态资源目录
  默认: 当前运行目录
*&#x2F;
const publics &#x3D; __dirname

const server &#x3D; new Pavane(watches, publics)

server.listener &#x3D; (args) &#x3D;&gt; {
  const {
    event,        &#x2F;&#x2F; 文件信息 &#39;add&#39;, &#39;change&#39;, 或者服务器信息 &#39;info&#39; ...
    path,         &#x2F;&#x2F; 修改路径，当事件为 &#39;info&#39;, 为空
    message,      &#x2F;&#x2F; 服务器信息，如果事件为 &#39;info&#39;, 此时为空
    reloadCss,    &#x2F;&#x2F; 触发客户端 css 重置
    reloadPage,   &#x2F;&#x2F; 触发客户端刷新页面
  } &#x3D; args
  const { log } &#x3D; global.console

  if (event &#x3D;&#x3D;&#x3D; &#39;info&#39;) {
    log(message)  &#x2F;&#x2F; 输出服务器信息
    return
  }

  &#x2F;&#x2F; 获取当前改变文件的后缀，然后进行 css，js 构建之类
  const ext &#x3D; extname(path)

  if (ext &#x3D;&#x3D;&#x3D; &#39;.css&#39;) {
    reloadCss()   &#x2F;&#x2F; 重置 css
  } else {
    reloadPage()  &#x2F;&#x2F; 刷新页面
  }

  log(&#x60;${event} ${path}&#x60;) &#x2F;&#x2F; 输出当前信息
}

server.start(2222) &#x2F;&#x2F; 默认端口 2333

&#x2F;&#x2F; 另外一种方式获取当前状态
console.log(server.status)
&#x2F;*
{
  running: true,
  event: &#39;change&#39;,
  path: &#39;file path&#39;,
}
*&#x2F;</code></pre><h3>CLI 全局使用</h3><pre><code>$ pavane # 默认使用，当前目录作为监听文件变化目录，同时也作为静态服务器目录
$ pavane -p 2000 # 自定义端口
$ pavane -c # 使用配置启动
$ pavane -w src -s dist # 设置监听目录 src，静态 server 目录 dist

# pavane 可以简写为 pv
$ pv -p 2000</code></pre><p>使用配置启动需要在运行目录添加一个配置文件 <code>pavane.config.js</code></p>
<pre><code>const { extname } &#x3D; require(&#39;path&#39;)

module.exports &#x3D; {
  watches: [&#39;*.js&#39;, &#39;*.css&#39;, &#39;*.html&#39;, &#39;**&#x2F;*.html&#39;], &#x2F;&#x2F; 监听目录，文件, 目录, glob 匹配, 或者 数组
  publics: __dirname, &#x2F;&#x2F; 静态文件目录
  port: 2222, &#x2F;&#x2F; 端口
  listener(args) {
    const {
      event,
      path,
      message,
      reloadCss,
      reloadPage,
    } &#x3D; args
    const { log } &#x3D; global.console

    if (event &#x3D;&#x3D;&#x3D; &#39;info&#39;) {
      log(message)
      return
    }

    &#x2F;&#x2F; 获取当前改变文件后缀
    const ext &#x3D; extname(path)

    if (ext &#x3D;&#x3D;&#x3D; &#39;.css&#39;) {
      &#x2F;&#x2F; 这里可以进行一些 css 构建之类的
      &#x2F;&#x2F; 然后刷新页面 css
      reloadCss() 
    } else {
      &#x2F;&#x2F; 同样可以进行 js，html 之类的构建
      &#x2F;&#x2F; 然后刷新页面
      reloadPage()
    }

    log(&#x60;${event} ${path}&#x60;)
  }
}</code></pre><h3>在其他 web 服务上使用</h3><p>如果当前的应用是由 python，php 之类的应用，可能会有自己的 web 服务。如果需要引入 Pavane 的 LiveReload 能力也是可以的，只需要在应用的前端模板页面上相应位置加上这个 <code>script</code></p>
<pre><code>&lt;!-- 假设当前启动的服务端口是 2333 --&gt;
&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:2333&#x2F;_.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>这时候在模板目录启动 Pavane，修改模板文件，静态资源后就可以自动刷新页面了</p>
<h2>适用场景</h2><p>每个工具都具有自己相应的使用场景，所以 Pavane 的适用场景是</p>
<ul>
<li>简单静态页面开发，例如活动页面，宣传页面</li>
<li>前后端揉合的 web 应用，例如 python django 的后台页面</li>
<li>需要转码的前端页面，例如需要 less，sass，babel 转码的应用</li>
</ul>
<p>但是如果你的应用是前后端分离的单页应用，vue，react 之类的，还是直接上 webpack 构建工具吧，具有更高级的刷新页面功能</p>
]]></description><link>https:/acyort.am0200.com/posts/345496742.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/345496742.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 29 Jul 2018 05:21:59 GMT</pubDate></item><item><title><![CDATA[yukar - Chrome Extension JavaScript Code Editor]]></title><description><![CDATA[<p>yukar 是一个前端代码编辑预览工具，是一个 chrome 插件。你可以从 chrome web store 上安装 </p>
<p><a href="https://chrome.google.com/webstore/detail/yukar/ilbmpnheigbnilnbknenakbkkdmaemlp">https://chrome.google.com/webstore/detail/yukar/ilbmpnheigbnilnbknenakbkkdmaemlp</a></p>
<!-- more -->

<h3>为什么要造这个轮子</h3><ol>
<li><p>有很多在线代码编辑预览工具，类似 jsfiddle，codepen，但都不能离线使用，还经常一些资源被墙</p>
</li>
<li><p>js 新特性支持度不完整，很多都不支持 vue 的 JSX</p>
</li>
<li><p>一些类似插件不能跳过 CSP（Content Security Policy）资源加载</p>
</li>
<li><p>在线编辑器在复制黏贴测试代码需要来回切换 tab，很不方便</p>
</li>
<li><p>umd 模块资源可能不可用</p>
</li>
</ol>
<h3>功能介绍</h3><ol>
<li><p>ES6／7 的新特性支持</p>
<ul>
<li>Async／Await</li>
<li>Class Properties</li>
<li>Object Rest Spread</li>
<li>Decorators</li>
</ul>
</li>
<li><p>React JSX ／Vue JSX 支持</p>
</li>
<li><p>保存代码记录</p>
</li>
<li><p>Console 记录支持</p>
</li>
</ol>
<h3>相关图片</h3><img width="822" alt="screen shot 2018-05-23 at 10 39 15 am" src="https://user-images.githubusercontent.com/2193211/40400634-a50bf078-5e75-11e8-9ff8-63efacfee8c1.png">


<img width="814" alt="screen shot 2018-05-23 at 10 38 30 am" src="https://user-images.githubusercontent.com/2193211/40400636-a5edb44a-5e75-11e8-82ad-b9fdf446a358.png">


<img width="817" alt="screen shot 2018-05-23 at 10 38 10 am" src="https://user-images.githubusercontent.com/2193211/40400638-a690f786-5e75-11e8-90f9-59da5c395d75.png">


<img width="817" alt="screen shot 2018-05-23 at 10 38 01 am" src="https://user-images.githubusercontent.com/2193211/40400639-a72db6c0-5e75-11e8-89c0-629ff6c2c8f4.png">


<img width="819" alt="screen shot 2018-05-23 at 10 37 50 am" src="https://user-images.githubusercontent.com/2193211/40400640-a78aa088-5e75-11e8-812c-9be47b3792a1.png">
]]></description><link>https:/acyort.am0200.com/posts/326504914.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/326504914.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 26 May 2018 07:57:58 GMT</pubDate></item><item><title><![CDATA[关于浏览器直接使用 ES6 的一些简单介绍]]></title><description><![CDATA[<p>在浏览器端直接运行 ES6 代码通常可以这样做</p>
<p>首先引入 <code>babel-standalone</code></p>
<pre><code>&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;babel-standalone@6.26.0&#x2F;babel.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>然后就可以直接写 ES6 代码了</p>
<pre><code>&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;
class A {
  constructor() {
    this.a &#x3D; 0
  }
  log() {
    console.log(this.a)
  }
}
&lt;&#x2F;script&gt;</code></pre><p>当然也可以直接写 React JSX 相关</p>
<pre><code>&lt;!-- 需要引入 React 相关 --&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react@16&#x2F;umd&#x2F;react.production.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@16&#x2F;umd&#x2F;react-dom.production.min.js&quot;&gt;&lt;&#x2F;script&gt;

&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;
ReactDOM.render(
  &lt;div&gt;
    &lt;h1&gt;JSX&lt;&#x2F;h1&gt;
  &lt;&#x2F;div&gt;
, document.body)
&lt;&#x2F;script&gt;</code></pre><p>还可以文件引入方式来写 ES6 代码</p>
<pre><code>&lt;script type&#x3D;&quot;text&#x2F;babel&quot; src&#x3D;&quot;&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>通常要写一些更高级的 js 特性，还需要添加 <code>babel-standalone</code> 一些插件，例如需要支持 <code>class properties</code> 这时候需要这样做</p>
<pre><code>&lt;script type&#x3D;&quot;text&#x2F;babel&quot; data-plugins&#x3D;&quot;transform-class-properties&quot;&gt;
class Bork {
  instanceProperty &#x3D; &quot;bork&quot;;
  boundFunction &#x3D; () &#x3D;&gt; {
    return this.instanceProperty;
  }
}
&lt;&#x2F;script&gt;</code></pre><p>如果需要 <code>import</code> 其他模块，还需要引入 <code>es2015-modules-umd</code> 插件。插件列表可以参考这里：<a href="https://babeljs.io/docs/plugins/">https://babeljs.io/docs/plugins/</a></p>
<pre><code>&lt;script type&#x3D;&quot;text&#x2F;babel&quot; data-plugins&#x3D;&quot;transform-class-properties transform-es2015-modules-umd&quot;&gt;
import { Breadcrumb } from &#39;antd&#39;;

ReactDOM.render(
  &lt;Breadcrumb&gt;
    &lt;Breadcrumb.Item&gt;Home&lt;&#x2F;Breadcrumb.Item&gt;
    &lt;Breadcrumb.Item&gt;&lt;a href&#x3D;&quot;&quot;&gt;Application Center&lt;&#x2F;a&gt;&lt;&#x2F;Breadcrumb.Item&gt;
    &lt;Breadcrumb.Item&gt;&lt;a href&#x3D;&quot;&quot;&gt;Application List&lt;&#x2F;a&gt;&lt;&#x2F;Breadcrumb.Item&gt;
    &lt;Breadcrumb.Item&gt;An Application&lt;&#x2F;Breadcrumb.Item&gt;
  &lt;&#x2F;Breadcrumb&gt;
, mountNode);
&lt;&#x2F;script&gt;</code></pre><p>接下来写一些稍微 <code>正式</code> 的代码</p>
<pre><code>&lt;!-- 同样引入 React 相关 --&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react@16&#x2F;umd&#x2F;react.production.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@16&#x2F;umd&#x2F;react-dom.production.min.js&quot;&gt;&lt;&#x2F;script&gt;

&lt;script type&#x3D;&quot;text&#x2F;babel&quot; data-plugins&#x3D;&quot;transform-class-properties transform-es2015-modules-umd&quot;&gt;
import React, { Component } from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;

class Editor extends Component {
&#x2F;&#x2F; ...
}

class Main extends Component {
  &#x2F;&#x2F; ...
  render() {
    return (
      &lt;div&gt;
        &lt;Editor {...this.props} &#x2F;&gt;
      &lt;&#x2F;div&gt;
    )
  }
}
&lt;&#x2F;script&gt;</code></pre><p>不出意外，<code>console</code> 会得到一些类似错误提示</p>
<pre><code>Uncaught TypeError: Cannot read property &#39;Component&#39; of undefined</code></pre><p>通过测试试验，出现这样提示是因为引入的模块 <code>umd</code> 打包出来不符合标准，根据 <code>umd</code> 标准，<code>react</code> 的 libraryName 应该为 <code>react</code>，而不是 <code>React</code>。同样 <code>react-dom</code> 的 libraryName 应该为 <code>reactDom</code> 而不是 <code>ReactDOM</code></p>
<p>所以解决办法也很简单，加上对应 libraryName 的定义即可</p>
<pre><code>&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react@16&#x2F;umd&#x2F;react.production.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@16&#x2F;umd&#x2F;react-dom.production.min.js&quot;&gt;&lt;&#x2F;script&gt;

&lt;script&gt;
window[&#39;react&#39;] &#x3D; window.React
window[&#39;reactDom&#39;] &#x3D; window.ReactDOM
&lt;&#x2F;script&gt;

&lt;script type&#x3D;&quot;text&#x2F;babel&quot; data-plugins&#x3D;&quot;transform-class-properties transform-es2015-modules-umd&quot;&gt;
&#x2F;&#x2F; ...
&lt;&#x2F;script&gt;</code></pre><p>同样，当我们需要引入 <code>react-router</code> 时候，同样也需要做对应处理</p>
<pre><code>window[&#39;reactRouterDom&#39;] &#x3D; window.ReactRouterDOM
window[&#39;reactRouter&#39;] &#x3D; window.ReactRouter</code></pre><p>最后，总结一下浏览器写 ES6 + React <code>模板</code></p>
<pre><code>&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react@16&#x2F;umd&#x2F;react.production.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@16&#x2F;umd&#x2F;react-dom.production.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react-router-dom@4.2.2&#x2F;umd&#x2F;react-router-dom.min.js&quot;&gt;&lt;&#x2F;script&gt;

&lt;script&gt;
window[&#39;react&#39;] &#x3D; window.React
window[&#39;reactDom&#39;] &#x3D; window.ReactDOM
window[&#39;reactRouterDom&#39;] &#x3D; window.ReactRouterDOM
&lt;&#x2F;script&gt;

&lt;script type&#x3D;&quot;text&#x2F;babel&quot; data-plugins&#x3D;&quot;transform-class-properties transform-es2015-modules-umd&quot;&gt;
&#x2F;&#x2F; ...
&lt;&#x2F;script&gt;</code></pre><p>可能会有疑问：为什么要在浏览器做这样事情，为什么不直接用 <code>webpack</code> 之类的。这里说明一下，正常情况下我们的 webapp 是不应该这样子做，应该预先打包后发布。所以这种浏览器处理方式的使用场景是在展示，测试一些小 demo 时候使用的</p>
]]></description><link>https:/acyort.am0200.com/posts/322485220.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/322485220.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Fri, 18 May 2018 12:18:31 GMT</pubDate></item><item><title><![CDATA[使用 setTimeout 排序]]></title><description><![CDATA[<p>原理就是将要排序的数组的每一个项作为 <code>setTimeout</code> 时间参数，然后就可以排序了</p>
<p>排序时间跟数组最大值绝对值有关 :)</p>
<p>需要对数组的负数项做一下处理，因为 <code>setTimeout</code> 参数负数的话跟参数 0 是一样的</p>
<p>例子 <a href="https://jsfiddle.net/am0200/o0sz55pq/">JSFiddle</a></p>
<p>具体代码说明:</p>
<pre><code>&#x2F;&#x2F; 需要排序数组
const numbers &#x3D; [8, 0, 3, -1, 9, -3, -767, 4, 111, 999, 89];

async function sortArr(arr) {
  const left &#x3D; arr.filter(a &#x3D;&gt; a &lt; 0).map(a &#x3D;&gt; a * -1) &#x2F;&#x2F; 获取数组负数项并转成正数
  const right &#x3D; arr.filter(a &#x3D;&gt; a &gt;&#x3D; 0) &#x2F;&#x2F; 数组正数项
  const sortLeft &#x3D; (await sort(left)).map(a &#x3D;&gt; a * -1).reverse() &#x2F;&#x2F; 负数项排序后需要反向
  const sortRight &#x3D; await sort(right) &#x2F;&#x2F; 正数项排序

  return sortLeft.concat(sortRight)
} 

function sort(arr) {
  return new Promise((resolve) &#x3D;&gt; {
    let len &#x3D; arr.length
    const back &#x3D; []

    arr.forEach(item &#x3D;&gt; {
      setTimeout(() &#x3D;&gt; {
        back.push(item)
        len -&#x3D; 1
        if (len &#x3D;&#x3D;&#x3D; 0) {
          resolve(back) &#x2F;&#x2F; 完成排序
        }
      }, item) &#x2F;&#x2F; 以每个项作为时间
    })
  })
}

;(async () &#x3D;&gt; {
  document.body.innerHTML &#x3D; &#39;Before: &#39; + numbers.join(&#39;, &#39;) + &#39;&lt;br&gt;After: &#39; + (await sortArr(numbers)).join(&#39;, &#39;)
})()

&#x2F;&#x2F; 排序结果: [-767, -3, -1, 0, 3, 4, 8, 9, 89, 111, 999]</code></pre>]]></description><link>https:/acyort.am0200.com/posts/244718742.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/244718742.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 12 May 2018 06:51:29 GMT</pubDate></item><item><title><![CDATA[AcyOrt - 基于 Node.js 的静态网站生成框架]]></title><description><![CDATA[<p>AcyOrt 是一个简单的静态页面生成框架，由 GitHub 支持，基于 NodeJS 构建。通过这个框架你可以在 GitHub issues 上写作，并且你的网站可以自动构建。</p>
<!-- more -->

<p>项目地址：<a href="https://github.com/acyortjs/acyort">https://github.com/acyortjs/acyort</a></p>
<h2>主要特色</h2><h3>简单写作</h3><p>可以在任意时间位置把网站内容写在 issues 上，也不用担心图片文章存储问题</p>
<h3>多用户支持</h3><p>支持多用户写作，可以多个用户共同维护网站</p>
<h3>自动部署</h3><p>通过 GitHub 钩子以及 CircleCI 可以自动部署网站，不需要任何环境，仅需要一个浏览器</p>
<h3>插件支持</h3><p>内置插件系统，你可以通过插件轻松自定义网站</p>
<h2>DEMO</h2><p><a href="http://acyort.am0200.com/">http://acyort.am0200.com/</a></p>
<h2>说明文档</h2><p>你可以在官方网站获取：<a href="https://acyort.com/">https://acyort.com/</a></p>
]]></description><link>https:/acyort.am0200.com/posts/225371660.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/225371660.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 22 Apr 2018 09:34:11 GMT</pubDate></item><item><title><![CDATA[AcyOrt + VUE + JSON 博客]]></title><description><![CDATA[<p>这里使用 <a href="https://github.com/acyortjs/acyort">AcyOrt </a> 的 JSON 输出插件输出博客内容，基于 vue + webpack 组合开发的一个博客。</p>
<p>DEMO: <a href="http://aksdj4.am0200.com/">http://aksdj4.am0200.com/</a></p>
<p>项目地址: <a href="https://github.com/acyortjs/aksdj4">https://github.com/acyortjs/aksdj4</a></p>
<h2>JSON</h2><p>使用  <a href="https://github.com/acyortjs/acyort-json">acyort-json </a> 将项目 <a href="https://github.com/LoeiFy/Recordum/issues">Recordum</a> issue 生成 JSON: <a href="https://github.com/acyortjs/aksdj4/tree/gh-pages/json">https://github.com/acyortjs/aksdj4/tree/gh-pages/json</a></p>
<h2>开发说明</h2><p>基于 webpack 2 + vue 2，值得注意的是 <code>vue-loader</code> 已经包含了 <code>vue-hot-reload-api</code>, <code>vue-style-loader</code>，甚至 postcss，所以 vue 相关的 loader 只需要安装 <code>vue-loader</code>, <code>vue-template-compiler</code></p>
<h3>ES6</h3><p>因为我并没有用到很多 ES7 以上的特性，只用到 <code>Object rest spread</code> 所以 babel 插件选择了
<code>babel-plugin-transform-object-rest-spread</code>, <code>babel-preset-es2015</code></p>
<h3>CSS 预处理器</h3><p>这次使用了 <code>postcss</code>，没有选择 <code>sass</code>，因为不需要安装那么久，并且加上对应插件也类似的写法，选择插件有：<code>postcss-cssnext</code>, <code>postcss-import</code>。这里也不需要安装 <code>Autoprefixer</code>，因为 cssnext 自带了</p>
<h3>vue</h3><p>使用了 vue/vue-router/vuex/，没有用 <code>vue-resource</code>，选择了 <code>axios</code>，作者也推荐用 axios: <a href="https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4">https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4</a></p>
<h2>构建</h2><p>有几个构建要求，分离相关基础库，修改 js，css 互不影响缓存</p>
<h3>分离 css</h3><p>使用 <code>webpack-md5-hash</code> 插件，使用 <code>contenthash</code> 文件名，保证修改 js 不会影响 css</p>
<pre><code>loaders: {
  postcss: ExtractTextPlugin.extract({
    use: [
      {
        loader: &#39;css-loader&#39;,
        options: {
          minimize: true
        }
      },
      &#39;postcss-loader&#39;
    ],
    fallback: &#39;vue-style-loader&#39;
  })
}
...
new ExtractTextPlugin(&#39;[name].[contenthash:8].css&#39;)</code></pre><h3>提取公共库</h3><p>基本上不会修改这些基础库</p>
<pre><code>{
  entry: {
    vendors: [&#39;axios&#39;, &#39;vue&#39;, &#39;vuex&#39;, &#39;vue-router&#39;]
  }
}
...
new webpack.optimize.CommonsChunkPlugin({
  names: [&#39;vendors&#39;, &#39;manifest&#39;]
})</code></pre><p>使用 <code>html-webpack-plugin</code> 进行自动生成相应资源路径，然后生成的 html 会有 4 个资源路径</p>
<pre><code>...
&lt;link href&#x3D;&quot;&#x2F;build.0570f616.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;
...
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;manifest.d41d8cd9.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;vendors.a2c4ab5a.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;build.be4b1392.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>这里有个问题，虽然现在修改 js，css 文件不会改变，反过来 css 修改 js 也不会改变，但是每次生成的 manifest.xxxxxx.js 可能文件名不一样，但是内容也变化了，这里有一个 issue: <a href="https://github.com/erm0l0v/webpack-md5-hash/issues/9">https://github.com/erm0l0v/webpack-md5-hash/issues/9</a></p>
<p>并且这个 manifest.js 是很小的，纪录一些打包模块信息，单独出来产生一个请求觉得不太好，所以这里选择将这个文件 inject 到 html，这样也可以不管上面所说的文件不一致问题</p>
<p>使用 <code>html-webpack-inline-source-plugin</code> 将 manifest inline 到 index.html</p>
<pre><code>new HtmlWebpackPlugin({
  template: &#39;src&#x2F;index.html&#39;,
  inject: &#39;body&#39;,
  inlineSource: &#39;manifest+&#39; &#x2F;&#x2F; 将 manifest 开头的 inline script
})</code></pre><h2>路由选择</h2><p>vue-router 也有两种路由模式选择，hash 模式以及 history 模式，history 模式需要服务器支持。因为项目是寄存在 GitHub pages 上，不能配置服务器，但这里还是使用了 history 模式。</p>
<p>因为 GitHub pages 支持 404.html，所以直接将生成的 index.html 复制生成一份 404.html，那么访问不存在路径就直接访问 404.html，就相当于访问 index.html，虽然这时候的 http code 是 404，但整个项目功能并没有受到影响</p>
]]></description><link>https:/acyort.am0200.com/posts/223304114.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/223304114.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 22 Apr 2018 09:41:27 GMT</pubDate></item><item><title><![CDATA[关于 react-router 的 browserHistory 模式]]></title><description><![CDATA[<p>SPA 项目基本上都会用到路由 <code>router</code>。react 还有 vue 对应有其路由插件。 react-router 还有 vue-router 都有 hashHistory 和 browserHistory 模式。这里大概说一下两者区别</p>
<!-- more -->

<ul>
<li>hashHistory: 不需要服务器配置，在 URL 生成一个 hash 来跟踪状态，通常在测试环境使用，也可以作为发布环境使用</li>
<li>browserHistory: 需要服务器端做配置，路径是真实的URL，是 react-router 官方推荐首选</li>
</ul>
<p>大多数情况下，browserHistory 模式明显是优于 hashHistory 模式的，但 browserHistory 需要一定的配置</p>
<h2>配置 browserHistory</h2><p>可以看出，hashHistory 不需要什么配置，但 browserHistory 需要服务端支持，这里简单说一下两种方式做支持，其它方式基本上都是类似</p>
<h3>使用 express</h3><pre><code>const app &#x3D; express()
app.get(&#39;*&#39;, function (request, response){
  response.sendFile(path.resolve(__dirname, &#39;index.html&#39;))
})</code></pre><h3>使用 nginx</h3><pre><code>server {
  ...
  location &#x2F; {
    try_files $uri &#x2F;index.html
  }
}</code></pre><p>这里说明一下为什么要这样设置，browserHistory 模式下，URL 是指向真实 URL 的资源路径，当通过真实 URL 访问网站的时候（首页），这个时候可以正常加载我们的网站资源，而用户在非首页下手动刷新网页时，由于路径是指向服务器的真实路径，但该路径下并没有相关资源，用户访问的资源不存在，返回给用户的是 404 错误</p>
<p>通过上面所说的原理，简单起来说就是 browserHistory 模式下，需要每个路由下都要有对应的资源存在，就不会产生 404 错误，所以如果不借助服务端的话，又要实现这种模式，这种场景在自己不能配置服务器时候会碰到，例如把项目部署到 <code>GitHub pages</code> 上。那该怎么办呢</p>
<blockquote>
<p>那么就产生 对应资源 </p>
</blockquote>
<p>所以，我们的做法就是在每个 <strong>路由路径</strong> 下，都放置一个跟首页一样的 <code>index.html</code></p>
<p>下面是做法，当然也是有各种方式的，都是可以类推的</p>
<p>假定我们有以下的路由设定，这里以 react-router 为例子</p>
<pre><code>export default (
  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;{App}&gt;
    &lt;IndexRoute component&#x3D;{HomePage} &#x2F;&gt;
    &lt;Route path&#x3D;&quot;contact-us&quot; component&#x3D;{ContactPage} &#x2F;&gt;
    &lt;Route path&#x3D;&quot;dashboard&quot;&gt;
      &lt;IndexRoute component&#x3D;{Verify(Dashboard)} &#x2F;&gt;
      &lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;{Verify(Inbox)} &#x2F;&gt;
      &lt;Route path&#x3D;&quot;conversation&quot; component&#x3D;{Verify(ComposeMessage)} &#x2F;&gt;
    &lt;&#x2F;Route&gt;
    &lt;Route path&#x3D;&quot;*&quot; component&#x3D;{NotFound} &#x2F;&gt;
  &lt;&#x2F;Route&gt;
)</code></pre><p>那么就可以路由路径为</p>
<pre><code>&#x2F;&#x2F; routes.js
const routes &#x3D; [
  &#39;contact-us&#39;,
  &#39;dashboard&#39;,
  &#39;dashborad&#x2F;inbox&#39;,
  &#39;dashboard&#x2F;conversation&#39;
]

module.exports &#x3D; routes</code></pre><p>接下来我们就把生成的 <code>index.html</code> 复制到这几个路径下就可以了</p>
<pre><code>&#x2F;&#x2F; deploy.js
const fs &#x3D; require(&#39;fs-extra&#39;)
const routes &#x3D; require(&#39;routes.js&#39;)
const path &#x3D; require(&#39;path&#39;)
routes.forEach((route) &#x3D;&gt; {
  fs.copySync(&#39;index.html&#39;, path.join(route, &#39;index.html&#39;))
})</code></pre><p>这样用户访问就不会出现 404 了，SPA 的功能也不受影响，为了方便我们可以把这个生成工具集成到 <code>package.json</code></p>
<pre><code>{
  &quot;script&quot;: {
    &quot;build&quot;: &quot;NODE_ENV&#x3D;production webpack --progress &amp;&amp; node deploy.js&quot;
  }
}</code></pre><p>ok, 当我们运行 <code>npm run build</code> 时候，就会同时生成对应路径下的 <code>index.html</code>，这样就可以了完成我们所需要的功能了</p>
<h2>问题 &amp; 思考</h2><p>看到这里，应该会有一个疑问，如果 routes 中有一些是不能穷举的路径要怎么办？例如 <code>&lt;Route path=&quot;posts/:id&quot; component={Verify(Inbox)} /&gt;</code>。这时候是没办法生成对应资源的</p>
<p>不过还是可以使用以下 hack 方式：</p>
<p>直接使用服务端 404 页面了，如果是用 <code>GitHub pages</code> 的话，我们可以直接生成一个 <code>404.html</code> 即可，直接把 404 页面弄成跟 index 内容一样，404 时候就是正常的内容页面，这时候页面功能是正常的，并且不需要前面的一对做法了。</p>
]]></description><link>https:/acyort.am0200.com/posts/210285498.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/210285498.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 22 Apr 2018 10:13:13 GMT</pubDate></item><item><title><![CDATA[黑苹果]]></title><description><![CDATA[<p>也算是完成了读书时候的心愿，以前读书时候老想着弄个黑苹果，但是一直没有成功。最近折腾安装前后花的时间就两三天那样，参考了一堆前人经验，所以不会很折腾，总体上算是完美的</p>
<!-- more -->

<h2>黑苹果情况</h2><p><img src="https://cloud.githubusercontent.com/assets/2193211/22615077/d8cde9de-eac7-11e6-98be-6531cc36bc61.png" alt="screen shot 2017-02-04 at 10 30 35 am"></p>
<h3>正常部分</h3><ul>
<li>显卡(HD530)，声卡，网卡驱动正常</li>
<li>USB 3 识别正常</li>
<li>CPU 可以变频</li>
<li>SSD TRIM 正常</li>
</ul>
<h3>问题</h3><ul>
<li>不能休眠/睡眠，因为是台式机，不理会</li>
<li>开机偶尔会出现禁止符号，拔掉/换接口 usb 就可以，应该是 usb 驱动问题吧，经常不关机不理会</li>
<li>开机过程会有一瞬间花屏现象，不影响使用，不理会</li>
</ul>
<h2>机器配置</h2><ul>
<li>CPU: i5-6500 散 </li>
<li>主板: 微星 B150i GAMING PRO </li>
<li>内存: 金士顿 8G*2 </li>
<li>显卡: 内置集显</li>
<li>机箱: 迎广肖邦</li>
<li>电源: 机箱内置 </li>
<li>SSD: Crucial_CT960M500 (之前没有用到的) </li>
</ul>
<h2>安装过程</h2><p>主要参考：<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-sierra-on-any-supported-intel-based-pc.200564/">https://www.tonymacx86.com/threads/unibeast-install-macos-sierra-on-any-supported-intel-based-pc.200564/</a></p>
<p>需要 3 个软件 <code>UniBeast</code>, <code>MultiBeast</code>, <code>Clover Configurator</code></p>
<p>usb 启动盘相关都是在 MacBook air 上操作的，教程上制作软件需要在英文系统下操作</p>
<h3>BIOS 设置</h3><ul>
<li><p>settings\高级\整合周边设备： SATA模式 - AHCI模式</p>
</li>
<li><p>settings\高级\USB设置： XHCI Hand-off - 允许</p>
</li>
<li><p>settings\高级\超级IO配置\串口0配置： 串口0 - 禁止</p>
</li>
<li><p>settings\启动： 启动模式选择 - UEFI</p>
</li>
<li><p>Overclocking\CPU 特征： CFG 锁定 - 禁止</p>
</li>
<li><p><del>Overclocking\CPU 特征： Intel 虚拟化技术 - 禁止 ／ Intel VT-D 技术 - 禁止</del></p>
</li>
</ul>
<h3>UniBeast 制作安装启动盘</h3><ul>
<li>格式化 U 盘：USB/OS X Extended (Journaled)/GUID Partition Map</li>
<li>写入 macOS Sierra 镜像，过程有点长，慢慢等</li>
</ul>
<p>安装完成将需要的设置软件 <code>MultiBeast</code>, <code>Clover Configurator</code> 拖入 U 盘保存，后续需要</p>
<h3>安装系统</h3><ul>
<li>开机 F11 选择 U 盘启动</li>
<li>磁盘工具格式化硬盘：Sierra/OS X Extended (Journaled)/GUID Partition Map</li>
<li>安装，然后提示重启</li>
<li>重启后选择 U 盘启动，启动刚刚安装的 Sierra，继续完成安装</li>
</ul>
<h3>系统设置</h3><p>完成安装后，这时候系统还没有相关驱动，打开相应软件进行设置</p>
<p><strong>使用 <code>MutiBeast</code> 进行驱动相关设置</strong></p>
<ul>
<li>Quick Start: UEFI Boot Mode</li>
<li>Audio: Realtek ALCxxx - ALC887/888b, Optional HD 3000/HD 4000/HD 530 HDMI Audio</li>
<li>Network: Realtek - RealtekRTL8111 v2.2.1</li>
<li>Graphics Configuration: Intel HD 530</li>
<li><p>SSDT Options: Sandy Bridge Core i5</p>
<p><strong>plist 设置</strong></p>
</li>
</ul>
<p>使用 <code>Clover Configurator</code> mount EFI 分区，用 sublime 打开 EFI/CLOVER/config.plist，添加对应字段</p>
<pre><code>&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;
&lt;plist version&#x3D;&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;Devices&lt;&#x2F;key&gt;
    &lt;dict&gt;
        &lt;key&gt;AddProperties&lt;&#x2F;key&gt;
        &lt;array&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL,Gfx324&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                AQAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL,GfxYTile&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                AQAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelCycleDelay&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                +gAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerDown&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                PAAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerOff&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                EQAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerOn&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                GQEAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerUp&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                MAAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;graphic-options&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                DAAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;hda-gfx&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;string&gt;onboard-1&lt;&#x2F;string&gt;
            &lt;&#x2F;dict&gt;
        &lt;&#x2F;array&gt;
    &lt;&#x2F;dict&gt;
&lt;&#x2F;dict&gt;
&lt;&#x2F;plist&gt;</code></pre><p><strong>kexts</strong></p>
<p>复制 <code>FakeSMC.kext</code>, <code>RealtekRTL8111.kext</code>, <code>VoodooHDA.kext</code> 到 EFI/CLOVER／kexts／other</p>
<p><strong>ssd trim</strong></p>
<p>输入相关命令重启即可</p>
<pre><code>sudo trimforce enable</code></pre><p><strong>默认启动</strong> </p>
<p>config.plist／Boot/DefaultVolume 的 ‘值’ 改成你的启动盘(Sierra)，默认为 macHDD</p>
]]></description><link>https:/acyort.am0200.com/posts/205319771.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/205319771.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 21 Jul 2018 11:55:02 GMT</pubDate></item><item><title><![CDATA[Adobe CEP 扩展]]></title><description><![CDATA[<p>Adobe 系列通常情况下宿主应用是不会运行未经签名扩展的，只有打包并签名才可以运行。但是可以打开开发者模式</p>
<!-- more -->

<h2>启用开发者模式</h2><h3>Windows</h3><p>打开到注册表定位到: ( 高版本类推 )</p>
<ul>
<li>CC 2014: <code>HKEY_CURRENT_USER\Software\Adobe\CSXS.5</code></li>
<li>CC 2015: <code>HKEY_CURRENT_USER\Software\Adobe\CSXS.6</code></li>
</ul>
<p>将 <code>PlayerDebugMode</code> 设置为 <code>1</code></p>
<h3>macOS</h3><p>终端输入: ( 同样高版本类推 )</p>
<p><code>defaults write com.adobe.CSXS.6 PlayerDebugMode 1</code></p>
<h2>扩展签名打包</h2><p>使用 Adobe 官方提供的 ZXPSignCmd
<a href="https://github.com/Adobe-CEP/CEP-Resources/tree/master/ZXPSignCMD">https://github.com/Adobe-CEP/CEP-Resources/tree/master/ZXPSignCMD</a></p>
<p><img src="https://cloud.githubusercontent.com/assets/2193211/21304385/cae9241a-c5ff-11e6-98fb-1ef0e84ee80e.png" alt="71097-6671c44f605ce86a"></p>
<p>以下为 macOS 下操作，Windows 类似。先进入文件目录</p>
<h3>创建证书</h3><pre><code>.&#x2F;ZXPSignCmd -selfSignedCert &lt;countryCode&gt; &lt;stateOrProvince&gt; &lt;organization&gt; &lt;commonName&gt; &lt;password&gt; &lt;outputPath.p12&gt;
.&#x2F;ZXPSignCmd -selfSignedCert &lt;国家代码&gt; &lt;地区&gt; &lt;组织名&gt; &lt;证书所有者名称&gt; &lt;证书密码&gt; &lt;证书名.p12&gt;

# example
.&#x2F;ZXPSignCmd -selfSignedCert CN guangzhou lorem.in loeify aksdj4 lorem.p12</code></pre><h3>签名并打包</h3><pre><code>.&#x2F;ZXPSignCmd -sign &lt;inputDirectory&gt; &lt;outputZxp&gt; &lt;p12&gt; &lt;p12Password&gt;
.&#x2F;ZXPSignCmd -sign &lt;要打包的项目目录&gt; &lt;输出文件路径&gt; &lt;证书路径&gt; &lt;证书密码&gt;

# example
.&#x2F;ZXPSignCmd -sign xxx xxx.zxp lorem.p12 aksdj4</code></pre><p>打包生成后的 <code>zxp</code> 是 <code>zip</code> 一样的可以解压</p>
<h2>手动安装插件</h2><h3>目录</h3><p>将插件解压，放进目录</p>
<p><strong>Windows</strong></p>
<p><code>C:\Program Files\Common Files\Adobe\CEP\extensions\</code></p>
<p><strong>macOS ( 注意是全局 Library，不是用户的 )</strong></p>
<p><code>/Library/Application Support/Adobe/CEP/extensions/</code></p>
<p>注意最终插件 xxx 放入目录最终应该存在 <code>/extensions/xxx/index.html</code></p>
<h3>启用</h3><p>重启 photoshop，选择 &quot;Window&quot; → &quot;Extensions&quot; → &quot;xxx&quot; 启用 </p>
<h2>参考文章</h2><ul>
<li><a href="http://nullice.com/archives/1741">Adobe CEP 扩展开发教程 「 4 」签名与打包</a></li>
<li><a href="http://nullice.com/archives/1665">Adobe CEP 扩展开发教程 「 1 」Hello World!</a></li>
</ul>
]]></description><link>https:/acyort.am0200.com/posts/196350551.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/196350551.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 22 Apr 2018 11:14:28 GMT</pubDate></item><item><title><![CDATA[Mirror - 基于 issues 的博客工具]]></title><description><![CDATA[<p>Mirror 是一个简单的博客工具，基于 GitHub API 获取 issues 数据，然后展示在页面上。</p>
<p>该工具的方便之处在于只需要在 issue 上写你的博客文章，你的网站会自动更新博客内容。</p>
<p>借助 GitHub，你可以轻松的用 markdown 书写你的博客内容，永久保存，不用担心数据丢失问题。还可以非常方便上传博客图片，拖入编辑器即可。</p>
<p>该博客工具非常适合以 issue 作为自己博客的用户，无痛生成博客网站，对原来内容毫无影响</p>
<p>Mirror 还支持多用户协作，你可以方便的设置哪些用户写的内容可以显示在博客网站上，避免无关内容</p>
<p>Mirror 在移动端同时有很好的浏览体验</p>
<h2>预览地址</h2><p><a href="http://mirror.am0200.com/">http://mirror.am0200.com/</a></p>
<h2>项目地址</h2><p><a href="https://github.com/LoeiFy/Mirror">https://github.com/LoeiFy/Mirror</a></p>
<p>新版本使用 GitHub <a href="https://developer.github.com/v4/">GraphQL</a> API</p>
<p><code>REST API</code> 版本：<a href="https://github.com/LoeiFy/Mirror/tree/rest-api">https://github.com/LoeiFy/Mirror/tree/rest-api</a></p>
<p>Demo：<a href="http://mirror.am0200.com/rest-api/">http://mirror.am0200.com/rest-api/</a></p>
<p>更详细的介绍可以看项目说明</p>
<h2>如何安装</h2><p>安装很简单，需要一个 nodejs 环境，一个简单的命令即可，如果没有 nodejs 环境，可以直接下载资源包自己配置，后面会有说明</p>
<pre><code>$ sudo npm install Mirror -g</code></pre><h2>使用</h2><h3>新建</h3><pre><code>$ cd newblog
$ mirror init </code></pre><p>或者</p>
<pre><code>$ mirror init newblog</code></pre><p>完成后你的 blog 就在 newblog 这里</p>
<h3>配置你的 blog</h3><p>首先需要获取你的 access token，这个 token 只要只读权限</p>
<p><a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p>
<p>只需要勾选两个选择，其他不要勾选</p>
<ul>
<li>read:user Read all user profile data</li>
<li>user:email Access user email addresses (read-only)</li>
</ul>
<p>修改 <code>config.yml</code></p>
<pre><code># 标题
title: Mirror

# github 用户名
user: LoeiFy

# blog 内容来源 repo
repo: Recordum

# 多用户，设定哪些用户写的 issue 内容可以展示出来，项目的用户名会自动包括进来
# 多个用户用逗号（英文逗号）隔开，例如：user0,user1
authors: 

# token
# token 需要用 &#x60;#&#x60; 符号分割
# 例子: 5#c31bffc137f44faf7efc4a84da827g7ca2cfeaa
token:

# 分页
per_page: 10</code></pre><h3>生成博客</h3><pre><code>$ mirror build</code></pre><h3>发布你的 blog</h3><p>你可以添加域名到 <code>CNAME</code></p>
<p>push 文件到一个 repo 的 <code>gh-pages</code> 分支</p>
<p>参考例子：<a href="https://github.com/LoeiFy/Mirror/tree/gh-pages">https://github.com/LoeiFy/Mirror/tree/gh-pages</a></p>
<h3>最后</h3><p>现在你可以在 github issue  上写博客了，内容会同步更新。一个例子</p>
<blockquote>
<p>在 <a href="https://github.com/LoeiFy/Recordum/issues">https://github.com/LoeiFy/Recordum/issues</a> 这个 issue 上写博客内容，对应网站 
<a href="https://mirror.am0200.com/">https://mirror.am0200.com/</a> 会自动同步更新内容</p>
</blockquote>
<h2>另一种安装方式</h2><p>你可以直接下载资源包，下载最新的 release，然后打开 <code>index.html</code> 进行配置，按照例子进行配置即可</p>
<p><a href="https://github.com/LoeiFy/Mirror/raw/master/mirror.zip">https://github.com/LoeiFy/Mirror/raw/master/mirror.zip</a></p>
<pre><code>&lt;!-- index.html --&gt;

&lt;script&gt;
&#x2F;*
**
** blog config here
** token should be separated by &#39;#&#39;.
** example: 5#c31bffc137f44faf7efcs4544da827g7ca2cfeaa
** muti-authors should be separated by &#39;,&#39;. and the user is included in.
** example: &#39;LoeiFy, author0&#39;
**
*&#x2F;

window.config &#x3D; {&quot;title&quot;:&quot;&quot;,&quot;user&quot;:&quot;&quot;,&quot;repository&quot;:&quot;&quot;,&quot;authors&quot;:&quot;&quot;,&quot;perpage&quot;:&quot;&quot;,&quot;token&quot;:&quot;&quot;}
&lt;&#x2F;script&gt;</code></pre><p>配置好后，可以先尝试本地预览，需要一个本地服务器，放上去访问 <code>index.html</code> 即可，测试没问题就可以把全部文件上传到对应地址即可，也可以放到 GitHub pages 上</p>
<h2>名字来源</h2><p><code>Mirror</code> 是 <code>DJ Okawari</code> 所作的专辑</p>
<p><img src="https://cloud.githubusercontent.com/assets/2193211/12321915/c66d8b12-baeb-11e5-9612-b188f5272e3b.jpg" alt="mirror"></p>
]]></description><link>https:/acyort.am0200.com/posts/126817142.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/126817142.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 29 Jul 2018 04:07:40 GMT</pubDate></item><item><title><![CDATA[输入框输入值自动格式化]]></title><description><![CDATA[<p>这里说的自动格式化是指当用户在输入框里面输入数字，例如银行卡号，为了方便用户输入，希望在输入过程中对输入数字进行加空格处理，优化用户体验</p>
<!-- more -->

<p>先看一下例子: <a href="http://jsfiddle.net/am0200/qugp8tvL/">http://jsfiddle.net/am0200/qugp8tvL/</a></p>
<p>注意例子里面的输入框的类型是 <code>tel</code>，而不是 <code>number</code>，主要原因是 <code>number</code> 类型</p>
<ul>
<li>会导致 Android 上某些系统不显示 <code>placeholder</code></li>
<li>无法插入非数字内容，例如空格</li>
</ul>
<h3>代码实现</h3><p><code>data-gap</code> 代表第几位开始加空格，不为 0</p>
<pre><code>&lt;input data-gap&#x3D;4 maxlength&#x3D;&quot;24&quot; size&#x3D;&quot;30&quot; autocomplete&#x3D;&quot;off&quot; type&#x3D;&quot;tel&quot; placeholder&#x3D;&quot;请输入卡号&quot;&#x2F;&gt;</code></pre><p>原理就是获取用户输入内容，格式化处理完成后再填入输入框</p>
<pre><code>var input &#x3D; document.querySelectorAll(&#39;input&#39;)[0]
var gap &#x3D; parseInt(input.getAttribute(&#39;data-gap&#39;))

input.oninput &#x3D; function() {
  var numbers &#x3D; this.value.replace(&#x2F;\s+&#x2F;g, &#39;&#39;).split(&#39;&#39;)     &#x2F;&#x2F; 获取原始值
  var back &#x3D; &#39;&#39; 

  numbers.forEach(function(n, i) {
    back +&#x3D; n + ((i + 1) % gap &#x3D;&#x3D;&#x3D; 0 ? &#39; &#39; : &#39;&#39;)    &#x2F;&#x2F; 处理加空格
  })

  var len &#x3D; back.length
  var last &#x3D; back.charAt(len - 1)

  if (last &#x3D;&#x3D;&#x3D; &#39; &#39; || isNaN(last)) {
    back &#x3D; back.substring(0, len - 1)    &#x2F;&#x2F; 移除末尾无用字符
  }

  this.value &#x3D; back

  &#x2F;&#x2F; 兼容处理
  setTimeout(function() {
    this.setSelectionRange(len, len)
    this.focus()
  }.bind(this), 0)
}</code></pre><p>获取输入原始值</p>
<pre><code>input.value.replace(&#x2F;\s+&#x2F;g, &#39;&#39;)</code></pre><h3>扩展</h3><p>可以设置格式化分割字符，例如用 <code>-</code> 代替空格，还可以设定不规则位数空格，具体可以修改处理条件即可</p>
]]></description><link>https:/acyort.am0200.com/posts/71470122.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/71470122.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Mon, 18 Dec 2017 08:49:25 GMT</pubDate></item><item><title><![CDATA[创建类似 http://ithinkimight.com/ 随机大小排布界面]]></title><description><![CDATA[<p><code>ithinkimight.com</code> 这个网站图片来自 Instagram，图片随机大小，位置也是随机，图片可以重叠，但是并没有 <strong>过分</strong> 重叠。这种随机大小，位置排版页面元素跟平常的整齐 <code>grid</code> 或者 <code>瀑布流</code> 风格很不一样，下面我们尝试一下实现类似效果</p>
<!-- more -->

<p>从网站源文件上看并不能看出网站是如何随机排布这些图片，因为是后端直接输出图片的位置参数，并不是前端实现的位置计算。不过这里有一种简单方法，可以实现类似效果。先看一下具体效果</p>
<h3>例子以及实际运用效果</h3><p><a href="http://jsfiddle.net/am0200/1mn5xbf8/">http://jsfiddle.net/am0200/1mn5xbf8/</a></p>
<p><a href="http://stone.am0200.com/">http://stone.am0200.com/</a></p>
<h3>实现思路</h3><p>首先把 container 划分为 4 个块，然后需要随机定位的 4 个块分别放到这 4 个区域，最后定义这 4 个块距离左边跟上边的最远，最近距离即可</p>
<h3>实现代码</h3><p>html 部分，我们只是生成 4 个容器，每个容器都可以放置一张图片</p>
<pre><code>&lt;section&gt;
    &lt;div id&#x3D;&quot;d0&quot;&gt;&lt;&#x2F;div&gt;
    &lt;div id&#x3D;&quot;d1&quot;&gt;&lt;&#x2F;div&gt;
    &lt;div id&#x3D;&quot;d2&quot;&gt;&lt;&#x2F;div&gt;
    &lt;div id&#x3D;&quot;d3&quot;&gt;&lt;&#x2F;div&gt;
&lt;&#x2F;section&gt;</code></pre><p>css 部分，我们使用绝对定位来设置每个容器的主要位置</p>
<pre><code>section {
    width: 100%;
    height: 100%;
    position: relative;
}
section div {
    position: absolute;
}
#d0 {
    left: 50%;
    top: 0;
}
#d1 {
    top: 50%;
    left: 50%;
}
#d2 {
    left: 0;
    top: 50%;
}
#d3 {
    left: 0;
    top: 0;
}</code></pre><p>js 部分，我们设置 4 个块随机大小，并且随机上下左右距离，需要注意的是，这个距离是有一定的范围的</p>
<pre><code>function rd(n,m){
    var c &#x3D; m-n+1;  
    return Math.floor(Math.random() * c + n);
}

var w &#x3D; parseInt($(&#39;section&#39;).width()),
    h &#x3D; parseInt($(&#39;section&#39;).height());

$(&#39;div&#39;).each(function() {
    var wh &#x3D; rd(150, 200)
    $(this).css({
        width: wh,
        height: wh
    })
})

var d0 &#x3D; parseInt($(&#39;#d0&#39;).width()),
    d1 &#x3D; parseInt($(&#39;#d1&#39;).width()),
    d2 &#x3D; parseInt($(&#39;#d2&#39;).width()),
    d3 &#x3D; parseInt($(&#39;#d3&#39;).width());

var a1 &#x3D; rd(-(d0 &#x2F; 4), w &#x2F; 2 - d0),
    a2 &#x3D; rd(0, h &#x2F; 2 - d0 &#x2F; 4 * 3);

var b1 &#x3D; rd(-(d1 &#x2F; 4), w &#x2F; 2 - d1),
    b2 &#x3D; rd(-(d1 &#x2F; 4), h &#x2F; 2 - d1);

var c1 &#x3D; rd(0, w &#x2F; 2 - d2 &#x2F; 4 * 3),
    c2 &#x3D; rd(-(d2 &#x2F; 4), h &#x2F; 2 - d2);    

var e1 &#x3D; rd(0, w &#x2F; 2 - d3 &#x2F; 4 * 3),
    e2 &#x3D; rd(0, h &#x2F; 2 - d3 &#x2F; 4 * 3); 


$(&#39;#d0&#39;).css(&#39;margin-left&#39;, a1 +&#39;px&#39;)
$(&#39;#d0&#39;).css(&#39;margin-top&#39;, a2 +&#39;px&#39;)

$(&#39;#d1&#39;).css(&#39;margin-left&#39;, b1 +&#39;px&#39;)
$(&#39;#d1&#39;).css(&#39;margin-top&#39;, b2 +&#39;px&#39;)

$(&#39;#d2&#39;).css(&#39;margin-left&#39;, c1 +&#39;px&#39;)
$(&#39;#d2&#39;).css(&#39;margin-top&#39;, c2 +&#39;px&#39;)

$(&#39;#d3&#39;).css(&#39;margin-left&#39;, e1 +&#39;px&#39;)
$(&#39;#d3&#39;).css(&#39;margin-top&#39;, e2 +&#39;px&#39;)
</code></pre><h3>其他问题</h3><p>这种定位简单方便，但是如果是单数块的时候，就要做一下相关处理了</p>
]]></description><link>https:/acyort.am0200.com/posts/71329290.html</link><guid isPermaLink="true">https:/acyort.am0200.com/posts/71329290.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Fri, 02 Feb 2018 16:30:22 GMT</pubDate></item></channel></rss>